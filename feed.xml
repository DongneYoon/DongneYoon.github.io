<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Stand alone with development</title>
  
  <subtitle>With the same mind as the first time...</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://slim8020.github.io/"/>
  <updated>2021-04-17T00:30:54.401Z</updated>
  <id>https://slim8020.github.io/</id>
  
  <author>
    <name>윤뚠뚠</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Adobe XD 플러그인 개발 시작 하기</title>
    <link href="https://slim8020.github.io/2019/08/16/FirstXDPlugin/"/>
    <id>https://slim8020.github.io/2019/08/16/FirstXDPlugin/</id>
    <published>2019-08-16T02:13:03.000Z</published>
    <updated>2021-04-17T00:30:54.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="전제-조건"><a href="#전제-조건" class="headerlink" title="전제 조건"></a>전제 조건</h1><p>아래와 같은 버전을 기준으로 XD 플러그인 개발 방법을 설명한다.</p><ul><li>개발환경 : Adob XD 22.0</li></ul><p>Adobe XD 플러그인을 개발하기 위해서는 기본적으로 HTML, CSS, Javascript 에 대한 기본 지식이 필요하다.</p><h1 id="Adobe-계정-생성"><a href="#Adobe-계정-생성" class="headerlink" title="Adobe 계정 생성"></a>Adobe 계정 생성</h1><p>Adobe 에 가입하고 계정을 만든다.</p><h1 id="플러그인-생성"><a href="#플러그인-생성" class="headerlink" title="플러그인 생성"></a>플러그인 생성</h1><ol><li>해당 경로 (<a href="https://console.adobe.io/plugins" target="_blank" rel="noopener">https://console.adobe.io/plugins</a>) 에 접속한다.</li><li>Create Plugin 을 클릭한다. </li><li>스타터 플러그인이 생성 되면 다운로드 받는다.</li></ol><h1 id="플러그인-개발-버전-설치"><a href="#플러그인-개발-버전-설치" class="headerlink" title="플러그인 개발 버전 설치"></a>플러그인 개발 버전 설치</h1><p>다운받은 스타터 플러그인으로 XD에 설치하여 바로 확인해 볼 수 있다.<br>스타터 플러그인을 설치하면 Hello 라는 플러그인 항목과 함께 실행 시키면 보라색 사각형이 그려진다.</p><p><img src="/img/FirstXDPlugin/adobeXDDevelopFolder.png" alt="개발 폴더 표시"></p><p>설치 방법은 플러그인 &gt; 개발 &gt; 개발 폴더 표시 후에, 다운로드 받은 파일의 압축을 해당 폴더에 풀어 놓으면 된다.<br>그리고 플러그인 리로드를 수행한다.</p><h1 id="플러그인-리로드"><a href="#플러그인-리로드" class="headerlink" title="플러그인 리로드"></a>플러그인 리로드</h1><p>플러그인을 수정 후에는 리로드를 수행 하여 변경 사항을 반영 해야 한다.<br><img src="/img/FirstXDPlugin/adobeXDReload.PNG" alt="플러그인 리로드"></p><h1 id="디버깅"><a href="#디버깅" class="headerlink" title="디버깅"></a>디버깅</h1><p>Adobe XD 에서 기본적으로 제공하는 디버깅 방법은 콘솔로 로그를 표시하는 방식이다.<br>js 파일에 아래와 같이 코드를 추가하면 코드 상에서 필요한 지점의 결과 값을 콘솔로 볼 수 있다.</p><p align="center"><br><font color="#1f1f1f"><b>console.log(“Say Hello!”);</b></font><br></p><p><img src="/img/FirstXDPlugin/DevelopConsole.png" alt="개발자 콘솔"></p><h1 id="폴더-구조"><a href="#폴더-구조" class="headerlink" title="폴더 구조"></a>폴더 구조</h1><ul><li>main.js : 동작에 대한 로직 구현</li><li>manifest.json : 플러그인의 이름, 메뉴 구조를 설정</li></ul><p>출처 : <a href="https://adobexdplatform.com/plugin-docs/tutorials/quick-start/" target="_blank" rel="noopener">https://adobexdplatform.com/plugin-docs/tutorials/quick-start/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;전제-조건&quot;&gt;&lt;a href=&quot;#전제-조건&quot; class=&quot;headerlink&quot; title=&quot;전제 조건&quot;&gt;&lt;/a&gt;전제 조건&lt;/h1&gt;&lt;p&gt;아래와 같은 버전을 기준으로 XD 플러그인 개발 방법을 설명한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;개발환경 : A
      
    
    </summary>
    
      <category term="Development" scheme="https://slim8020.github.io/categories/Development/"/>
    
    
      <category term="AdobeXD" scheme="https://slim8020.github.io/tags/AdobeXD/"/>
    
      <category term="Plugin" scheme="https://slim8020.github.io/tags/Plugin/"/>
    
      <category term="Development" scheme="https://slim8020.github.io/tags/Development/"/>
    
      <category term="어도비XD" scheme="https://slim8020.github.io/tags/%EC%96%B4%EB%8F%84%EB%B9%84XD/"/>
    
      <category term="플러그인" scheme="https://slim8020.github.io/tags/%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8/"/>
    
      <category term="개발" scheme="https://slim8020.github.io/tags/%EA%B0%9C%EB%B0%9C/"/>
    
  </entry>
  
  <entry>
    <title>비기능 요구 테스트 (Non-Functional Test)</title>
    <link href="https://slim8020.github.io/2019/08/10/SoftwareTest_nonFunctional/"/>
    <id>https://slim8020.github.io/2019/08/10/SoftwareTest_nonFunctional/</id>
    <published>2019-08-10T14:13:03.000Z</published>
    <updated>2021-04-17T00:30:56.344Z</updated>
    
    <content type="html"><![CDATA[<p>이 포스트는 “지식 제로부터 배우는 소프트웨어 테스트”를 읽고 학습한 내용입니다.</p><p>우리 팀은 테스트를 그렇게 잘하는 팀은 아니다. 테스트를 전혀 모르는 신입 한 명이 테스터의 전부다.<br>나도 개발자 출신이라 그동안에 테스트 활동을 옆에서만 지켜 봤지, 실제로 테스트를 수행 해 본적은 없다. 그래도 들은 풍월은 있어서 기능 요구 테스트와 비기능 요구 테스트를 각각 수행은 하고 있다.</p><p>이 책을 읽기 전에는 기능 요구 테스트는 단순히 기능별로 나눈 케이스로 테스트를 진행 했고, 비기능 요구 테스트는 최근에서야 소프트웨어의 동작 성능을 체크하는 수준이다. </p><p>이번에는 이 책에서 말하는 가장 어려운 테스트인 비기능 요구 테스트에 대해서 정리 해 보도록 하겠다.</p><h2 id="비기능-요구-테스트란"><a href="#비기능-요구-테스트란" class="headerlink" title="비기능 요구 테스트란?"></a>비기능 요구 테스트란?</h2><p>비기능 요구 테스트는 기능이 아닌 부분, 즉 품질 특성을 테스트하는 것을 말한다. 그렇다면 품질 특성에는 어떤 것들이 있을까? 아래 표(ISO 9126 품질 특성)와 같다.<br><img src="/img/SoftwareTest_NonFunctional/non-functionaltest.PNG" alt="ISO 9126 품질특성"></p><p>소프트웨어 아키텍트에게 설문한 결과 이 중에서 중요한 특성은 보안성, 신뢰성, 효율성 이라고 한다.<br>이 특성들을 모두 만족하는 것은 무리이며, 특성 간은 각각 Trade-off 관계라고 말하고 있다. </p><h2 id="성능-테스트-Performance-Test-란"><a href="#성능-테스트-Performance-Test-란" class="headerlink" title="성능 테스트(Performance Test) 란?"></a>성능 테스트(Performance Test) 란?</h2><p> 소프트웨어를 설계하거나 기획하는 단계에서 설정된 소프트웨어의 성능이 기대한 대로 나오는가를 확인하기 위한 테스트이다. (우리 팀에서도 성능 테스트를 종종 하는데, 주로 하는 것이 소프트웨어 로딩 시간 체크 이다.) 성능 테스트도 비기능 요구 테스트의 일부이다.</p><h3 id="성능-테스트시-주의-사항"><a href="#성능-테스트시-주의-사항" class="headerlink" title="성능 테스트시 주의 사항"></a>성능 테스트시 주의 사항</h3><ol><li><p>성능의 정의는 명확하게 해야 한다.<br>예를 들어<br> 30MB 를 처리할 때 1분 이내로 되어야 한다<br> 10MB 의 파일을 열 때 10초 이상이 걸리면 안된다<br> 소프트웨어를 실행 시키면 로딩 시간이 1분 이내로 모든 초기 작업을 완료 해야 한다<br>와 같은 정의가 명확해야 한다.</p></li><li><p>요구 정의대로만 테스트 케이스를 작성해서는 안된다.<br>테스트는 버그를 찾는 작업 이므로 요구가 정의 된 대로만 테스트가 수행이 되면 아무 의미가 없다.</p></li><li><p>성능 테스트는 미루지 말아야 한다.<br>성능 테스트에서 발견되는 버그는 최악의 버그다. 문제가 심한 경우 소프트웨어 구조 자체를 변경해야 하는 경우까지도 있을 수 있으므로 어느 정도 소프트웨어가 동작하는 시점에서는 수행하는 것이 좋다. </p></li></ol><h3 id="성능-테스트-5-단계-이-부분은-책에도-내용이-별로-없다"><a href="#성능-테스트-5-단계-이-부분은-책에도-내용이-별로-없다" class="headerlink" title="성능 테스트 5 단계 ( 이 부분은 책에도 내용이 별로 없다. )"></a>성능 테스트 5 단계 ( 이 부분은 책에도 내용이 별로 없다. )</h3><ol><li><p>아키텍처 검증<br>소프트웨어의 아키텍처 측면의 스펙을 검토 한다. 예를 들어 우리 팀의 경우 electron 기반의 데스크탑 앱을 만들고 있는데, electron 자체에서 지원하는 스펙이 동작하는데 적합한지를 확인 해야 한다.</p></li><li><p>성능 벤치 마크<br>실제 개발된 소프트웨어를 테스트 하는 것을 말한다. 소프트웨어의 로딩 시간을 측정 한다든가 하는 활동을 말한다.</p></li><li><p>성능 회귀 테스트<br>이 테스트는 프로그램 개발 도중에 항상 변하는 상태에서 수행 하는 것을 말한다. 기능 수정이 이루어진 부분만 테스트하는 것이 아니라, 기존에 확인 했던 다른 부분도 확인을 해 줘야 한다.</p></li><li><p>성능 튜닝 및 엑셉턴스 테스트<br>최종 제품이 요구 정의에 정해진 성능을 내는지 확인하는 것을 말한다.</p></li><li><p>24x7 성능 모니터링<br>실제 사용 하는 데이터로 테스트가 불 가능 할 경우 더미 데이터로 검토 하라는 이야기인데.. 왜 24x7 성능 모니터링인지… 모르겠다.</p></li></ol><p>나는 성능 테스트에 대해서는 크게 인사이트를 얻을 수 없었다.</p><h2 id="신뢰성-테스트"><a href="#신뢰성-테스트" class="headerlink" title="신뢰성 테스트"></a>신뢰성 테스트</h2><p>소프트웨어의 신뢰성을 측정 하려면 신뢰도 성장 곡선을 그려야 한다. 여기서 의미 있는 개념은 평균고장간격 (Mean Time Between Failure : MTBF ) 이라는 것인데, 단위 시간당 어느 정도의 Failure (버그나 시스템 멈춤, 재부팅)을 일으키는지 측정하는 것이다. 이를 통해 신뢰성을 판단 할 수 있다고 한다.<br>예를 들어 어떤 소프트웨어를 테스트 해서 평균 5시간 정도 조작하면 결국 느려진다던가 멈춘다거나 한다면 MTBF 는 5시간 이다. 그렇다면 소프트웨어의 요구 정의에서 MTBF 가 24시간 이상 되어야 한다 라고 하면 신뢰성 테스트의 기준이 될 것 같다. </p><p>그리고 신뢰도 성장 곡선에 대한 내용이 나오는데, 신뢰도 성장 곡선은 아래 수식으로 그릴 수 있다.</p><p>m(t) : 시간 축에 대한 신뢰성<br>a : 기대 하는 장애(버그)의 총 수<br>b : 버그 발견율<br>t : 테스트 실행 시간</p><p>최종적으로는 테스트 케이스 실행에 대해 버그 곡선을 그리는 것이 거의 의미가 없다고 말하고 있다.<br>(왜 설명한거지..)</p><p>일단은 그냥 이런 것이 있다 정도로 넘어가야 겠다. 설명도 명확치 않을 뿐 더러 어떻게 활용 해야 할지도 사실상 의문이다. 이 부분에 대해서는 다른 책을 좀 더 읽어보고 공부 하는 것으로 하겠다.  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이 포스트는 “지식 제로부터 배우는 소프트웨어 테스트”를 읽고 학습한 내용입니다.&lt;/p&gt;
&lt;p&gt;우리 팀은 테스트를 그렇게 잘하는 팀은 아니다. 테스트를 전혀 모르는 신입 한 명이 테스터의 전부다.&lt;br&gt;나도 개발자 출신이라 그동안에 테스트 활동을
      
    
    </summary>
    
      <category term="Software Test" scheme="https://slim8020.github.io/categories/Software-Test/"/>
    
    
      <category term="SoftwareTest" scheme="https://slim8020.github.io/tags/SoftwareTest/"/>
    
      <category term="Test" scheme="https://slim8020.github.io/tags/Test/"/>
    
      <category term="소프트웨어테스트" scheme="https://slim8020.github.io/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%ED%85%8C%EC%8A%A4%ED%8A%B8/"/>
    
      <category term="NonFunctional" scheme="https://slim8020.github.io/tags/NonFunctional/"/>
    
      <category term="PerformanceTest" scheme="https://slim8020.github.io/tags/PerformanceTest/"/>
    
      <category term="비기능테스트" scheme="https://slim8020.github.io/tags/%EB%B9%84%EA%B8%B0%EB%8A%A5%ED%85%8C%EC%8A%A4%ED%8A%B8/"/>
    
      <category term="성능테스트" scheme="https://slim8020.github.io/tags/%EC%84%B1%EB%8A%A5%ED%85%8C%EC%8A%A4%ED%8A%B8/"/>
    
  </entry>
  
  <entry>
    <title>탐색적 테스트(Exploratory Test)</title>
    <link href="https://slim8020.github.io/2019/08/09/SoftwareTest_.ExploratoryTesting/"/>
    <id>https://slim8020.github.io/2019/08/09/SoftwareTest_.ExploratoryTesting/</id>
    <published>2019-08-09T14:13:03.000Z</published>
    <updated>2021-04-17T00:30:36.482Z</updated>
    
    <content type="html"><![CDATA[<p>이 포스트는 “지식 제로부터 배우는 소프트웨어 테스트”를 읽고 학습한 내용입니다.</p><h1 id="탐색적-테스트"><a href="#탐색적-테스트" class="headerlink" title="탐색적 테스트"></a>탐색적 테스트</h1><p>지난 포스트에서 소개한 화이트 박스 테스트와 블랙 박스 테스트는 테스트 케이스 기반 테스트이다.<br>좀 더 쉽게 설명하면 테스트 케이스를 설계하고 테스트를 진행하는 형태의 테스트 방식이다.<br>이번에 소개하는 탐색적 테스트는 생각하며 테스트 하기 방식이다. </p><p>지난 포스트에서 “똑똑하지 않은 테스트를 시간만 많이 들인다고 소프트웨어 품질이 올라가지는 않는다”고 이야기 하자마자 보다 똑똑하게 테스트 하는 방법에 대해서 소개를 하고 있다.</p><h2 id="탐색적-테스트란"><a href="#탐색적-테스트란" class="headerlink" title="탐색적 테스트란?"></a>탐색적 테스트란?</h2><p>말 그대로 탐색 하면서 테스트를 진행하는 것이다. 반복하지만 생각하면서 테스트 하기 이다.<br>이 테스트 기법의 핵심은 소프트웨어의 특정 부분에 버그들이 집중되어 분포한다 라는 특성을 이용한 테스트 기법이다.</p><p>탐색적 테스트는 1983년에  Cem Kaner 교수가 제안한 방법인데, 그는 저자의 스승이라고 한다.<br>그는 이렇게 말했다.<br>탐색적 테스트는 소프트웨어 테스트 이해와 테스트 설계와<br>테스트 실행을 동시에 수행하는 테스트이다.<br><img src="/img/SoftwareTest_Exploratory/compare.PNG" alt="테스트 케이스 기반 테스트 vs 탐색적 테스트"></p><p>이 책에서는 테스트 케이스 실행으로 발견할 수 있는 버그는 전체의 50% 이하 일 것이라고 한다.<br>그럴 거라면 차라리 테스트 케이스를 일일이 사전에 작성하는 것보다는 생각하면서 소프트웨어를 테스트 하는 것이 낫다.</p><h3 id="테스트-케이스-기반-테스트의-단점"><a href="#테스트-케이스-기반-테스트의-단점" class="headerlink" title="테스트 케이스 기반 테스트의 단점"></a>테스트 케이스 기반 테스트의 단점</h3><ol><li><p>프로젝트 초기 단계에 테스트 케이스를 작성하려고 해도 대상이 되는 소프트웨어가 없으므로 어림짐작으로 케이스를 작성하는 경우가 많다. 최악의 경우 요구 사항을 나열 해 놓은 테스트 케이스가 작성된다. ( 우리 프로젝트의 경우 그런 경우가 많았다. )<br>요구사항이 명확치 않으므로 경계값 또한 모호하여 제대로 된 경계값 분석 조차 이루어지지 않는다.</p></li><li><p>너무 이른 테스트 케이스 작성은 소프트웨어 테스트 공수의 현저한 증가를 가져온다.</p></li><li><p>테스트 케이스 기반 테스트는 아래 두 가지가 결여되어 있다.<br> 가. 테스트를 실행하면서 어딘가 다른 부분에 문제가 없는지를 생각 해 보고 그 곳을 테스트 하는 것<br> 나. 소프트웨어에서 약한 부분을 발견 했다면 그곳의 집중적 테스트<br> 결과적으로 중요도나, 심각도, 버그 분포에 대한 고려가 없는 테스트이므로 비효율적이다.</p></li></ol><h2 id="탐색적-테스트-수행-방법"><a href="#탐색적-테스트-수행-방법" class="headerlink" title="탐색적 테스트 수행 방법"></a>탐색적 테스트 수행 방법</h2><ol><li><p>기준(Criteria)의 결정<br>탐색적 테스트 수행 전에 어떤 소프트웨어야 하는지에 관한 기준을 정해야 한다. 아래 표는 해당 예이다.<br><img src="/img/SoftwareTest_Exploratory/Criteria.PNG" alt="기준의 결정"></p></li><li><p>탐색적 테스트 수행<br>탐색적 테스트 수행은 아래의 다섯 가지 단계로 이루어진다.<br>가. 대상 소프트웨어를 정함.<br>나. 기능을 목록화 함.<br>다. 해당 기능들을 조사하여 약한 부분을 발견.<br>라. 각 기능을 테스트 하고 버그를 기록<br>마. 계속적인 테스트 실행</p></li></ol><h3 id="탐색적-테스트의-단점"><a href="#탐색적-테스트의-단점" class="headerlink" title="탐색적 테스트의 단점"></a>탐색적 테스트의 단점</h3><p>비기능 요구 테스트에 어울리지 않는다. 예외가 있다면 사용성(Usability)테스트이다. </p><p>테스트의 효율을 극대화 하기 위해서는..</p><p>일반적인(기술적인 이해도나 깊이가 없는) 테스터가 탐색적 테스트를 수행 하였을 경우에는 코드 커버리지가 테스트 케이스 기반의 테스트나 별반 차이가 없다.<br><img src="/img/SoftwareTest_Exploratory/before.jpg" alt="이해도가 없을 경우"></p><p>하지만 일반적인 테스터에게 개발자가 프로그램의 구조를 설명해 주고 테스트를 하면 아래와 같은 그래프가 나온다.<br><img src="/img/SoftwareTest_Exploratory/after.jpg" alt="이해도가 생긴 경우"></p><p>따라서 탐색적 테스트 + 기술을 갖춘 테스트 담당자의 조합이라면 짧은 시간에 최대의 결과를 얻을 수 있다.</p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>소프트웨어 설계 회의 시에 테스터를 참석 시키거나, 소프트웨어 설계가 완료 되었을 때 테스터에게 그 구조에 대해서 자세히 설명 해 준다면 탐색적 테스트를 수행하여 보다 나은 품질의 소프트웨어를 얻을 수 있다.또한 테스트의 스타일과 방법은 다양하다. 그 스타일과 방법을 적재적소에 적용할 수 있는가가 테스트의 성과를 좌우한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이 포스트는 “지식 제로부터 배우는 소프트웨어 테스트”를 읽고 학습한 내용입니다.&lt;/p&gt;
&lt;h1 id=&quot;탐색적-테스트&quot;&gt;&lt;a href=&quot;#탐색적-테스트&quot; class=&quot;headerlink&quot; title=&quot;탐색적 테스트&quot;&gt;&lt;/a&gt;탐색적 테스트&lt;/h1&gt;
      
    
    </summary>
    
      <category term="Software Test" scheme="https://slim8020.github.io/categories/Software-Test/"/>
    
    
      <category term="SoftwareTest" scheme="https://slim8020.github.io/tags/SoftwareTest/"/>
    
      <category term="Test" scheme="https://slim8020.github.io/tags/Test/"/>
    
      <category term="ExploratoryTest" scheme="https://slim8020.github.io/tags/ExploratoryTest/"/>
    
      <category term="탐색적테스트" scheme="https://slim8020.github.io/tags/%ED%83%90%EC%83%89%EC%A0%81%ED%85%8C%EC%8A%A4%ED%8A%B8/"/>
    
      <category term="소프트웨어테스트" scheme="https://slim8020.github.io/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%ED%85%8C%EC%8A%A4%ED%8A%B8/"/>
    
  </entry>
  
  <entry>
    <title>화이트박스 테스트와 블랙박스 테스트</title>
    <link href="https://slim8020.github.io/2019/08/08/SoftwareTest_WhiteBox_BlackBox/"/>
    <id>https://slim8020.github.io/2019/08/08/SoftwareTest_WhiteBox_BlackBox/</id>
    <published>2019-08-08T14:13:03.000Z</published>
    <updated>2021-04-17T00:38:24.257Z</updated>
    
    <content type="html"><![CDATA[<p>이번 포스팅에서는 화이트 박스 테스트와 블랙 박스 테스트에 대해서 이야기 해 보고자 한다.<br>물론 “지식 제로부터 배우는 소프트웨어 테스트” 를 읽고 공부한 내용이다.</p><h2 id="화이트-박스-테스트-란-무엇인가"><a href="#화이트-박스-테스트-란-무엇인가" class="headerlink" title="화이트 박스 테스트 란 무엇인가?"></a>화이트 박스 테스트 란 무엇인가?</h2><p>소프트웨어의 내부구조를 철저하게 분석하여 논리 구조가 올바른지 분석하는 테스트를 말한다. 정의 대로 논리 구조를 검증하는 테스트이므로 소프트웨어 사양이 잘못된 것은 검증할 수 없다.<br>이 책에서는 두 가지 정도를 이야기 하고 있다.</p><p>첫째, 제어 흐름 테스트  ( 소프트웨어의 동작 흐름 테스트 )이다. 제어 흐름 테스트는 말 그대로 논리적 흐름에 대한 테스트를 하는 것을 말한다. 여기서 커버리지라는 개념이 나오는데, 사전적 의미로 “범위” 를 말한다. </p><p>커버리지는 두 가지가 있는데, 스테이트먼트 커버리지와 브랜치 커버리지 이다. 스테이트먼트 커버리지는 말그대로 명령문만 테스트 하는 것을 말한다. 이것이 무슨 의미인가?<br>예를 들어 아래 코드에서 (a) 가 동작하는 경우와 (b)가 동작하는 경우만 테스트 하는 것을 말한다.<br>테스트 케이스로 i=1 이고 k=2인 경우를 테스트하면 (a)와 (b)를 테스트 할 수 있다.</p><pre><code>if(i&gt;0){   j = i+1;   //(a)}if(k&lt;3){   j = i-1;   //(b)}</code></pre><p>하지만 그 이외의 경우 i=0 이고 k=3 인 상황은 검증이 되지 않는다</p><p>그래서 브랜치 커버리지를 확인 해야 한다.<br>브랜치 커버리지는 분기를 테스트 하는 것을 말한다. i&gt;0 조건의 True 인 상황과 False 인 상황을 검증하고 k&lt;3 조건이 True 인 상황과 False 인 상황 모두를 검증 하는 것이다.</p><p>둘째, TDD (Test Driven Development)</p><p>TDD(테스트주도개발)는 사실 개발 방법론의 하나로 알고 있다. 저자도 말하고 있는 것은 TDD의 본질은 확실하게 품질을 보증하겠다는 의미보다는 변경에 강인하고 신속한 개발을 위한 방법이라는 것이다.<br>이 부분에 대해서는 따로 공부를 해봐야겠다.</p><p>실무에서는 화이트 박스 테스트는 테스터가 하기엔 어려움이 있고, 개발자가 주로 유닛테스트를 통해 진행하는 듯하다.</p><h2 id="블랙-박스-테스트-란-무엇인가"><a href="#블랙-박스-테스트-란-무엇인가" class="headerlink" title="블랙 박스 테스트 란 무엇인가?"></a>블랙 박스 테스트 란 무엇인가?</h2><p>블랙 박스 테스트는 프로그램을 일종의 블랙박스로 보고 다양한 입력을 실행함으로써 소스 코드를 이용하지 않고 테스트를 수행 하는 방법이다. 대부분의 실무에서 블랙박스 테스트 방법을 수행하고 있다.<br>블랙 박스 테스트의 기본적인 방법으로 등가 분할과 경계값 분석이 있다.</p><pre><code>if( a &gt;0 &amp;&amp; a &lt;100 &amp;&amp; b&gt;0 &amp;&amp; b&lt;100 ){    c = a*b;}else{    // input error}</code></pre><p>등가분할</p><p>‘등가분할’ 이란 입력 영역을 ‘등가 클래스’라는 부분 집합으로 분할 하고, 그 부분 집합에서 선택한 입력값을 모두 같은 값(등가)라고 보는 작업이다.</p><p>예를 들어 입력 A 를 1~99 까지 입력 가능하고, 입력 B 를 1~ 99 까지 입력이 가능 하다고 가정 할 때<br>출력 C = A <em>B 의 결과 출력하는 프로그램이 있다고 하자.<br>여기서 입력 할 수 있는 값을  A,B 모두 1~99 까지다. 사실상 1~99 사이의 어느 값 하나씩만 넣어 보면 c = a</em>b 의 결과는 동일하게 출력 된다. 이 부분을 유효 등가라고 하고 -1 을 입력 하거나 100 이상을 입력 하였을 경우는 에러가 된다. 이를 무효 등가라고 부른다.</p><p>유효 등가 클래스와 무효 등가 클래스로 각각 케이스를 만들어 보자.<br><img src="/img/SoftwareTest_White_Black/Equivalence_Partitioning.png" alt="등가분할 케이스"></p><p>유효 등가 테스트 케이스<br>(1) A=50 B=50</p><p>무효 등가 테스트 케이스<br>(2) A = -1, B = -1<br>(3) A = -2, B = 101<br>(4) A = 0, B = 50<br>(5) A = 50, B = 0<br>(6) A = 50, B = 101<br>(7) A = 101, B = 60<br>(8) A = 110, B = 110<br>(9) A = 105, B = -5<br>(10) A = 0, B = 0</p><p>총 10가지의 케이스가 나올 수 있다. 이렇게 간단한 경우에도 무효 등가가 9개나 있기 때문에 효율적으로 테스트하기 위해서는 케이스를 줄여야 한다. 저자는 이를 ‘실천적 등가 클래스 테스트(Weak Robust Equivalent Test’ 라고 부른다.<br>위의 예제에서 보면 (2)와 (8)이 무효 등가를 모두 포함하고 있음을 알 수 있다. 그래서 (1) 유효등가와 (2),(8),(10) 의 무효등가만 테스트하면 된다.( 여기서 A가 0 이고 B 가 0 인 경우는 항상 특별한 값이므로 입력할 수 있을 때는 항상 케이스에 포함하라고 한다. - 이유는 좀 알아봐야겠다. 잘 모르겠음.)</p><h2 id="경계값-분석"><a href="#경계값-분석" class="headerlink" title="경계값 분석"></a>경계값 분석</h2><p>소프트웨어에서 경계가 되는 부분의 값에 버그가 있을 확률이 높다고 한다. 그래서 이 부분을 테스트 해야 하는데 이를 경계값 분석이라고 한다. 여기서 경계가 되는 부분이라 함은 유효등가와 무효등가의 경계를 말한다. 소프트웨어에서는 무효등가와 유효등가 사이에 반드시 조건문이 필요한데, 이러한 조건문을 올바르게 작성하지 않는 경우가 있기 때문에 테스트 해야 한다고 한다.</p><h2 id="디시전-테이블-Decision-Table"><a href="#디시전-테이블-Decision-Table" class="headerlink" title="디시전 테이블 (Decision Table)"></a>디시전 테이블 (Decision Table)</h2><p>모든 입력의 조합을 표로 만든 다음에 이에 해당하는 동작이나 출력하는 방법을 말한다. 이 방법은 복잡한 상태가 얽힌 기능 테스트에 도움이 된다고 한다. 위의 예제로 디시전 테이블을 만들어 보도록 하겠다.</p><p>경우1 : A,B 모두 입력 값이 올바른 경우<br>경우2 : A는 올바른 입력이나 B 는 잘못된 입력인 경우<br>경우3 : A 는 잘못된 입력이나 B 는 올바른 입력인 경우<br>경우4 : A,B 둘다 잘못된 입력인 경우</p><p><img src="/img/SoftwareTest_White_Black/DecisionTable.png" alt="디시전 테이블"></p><p>이 방법은 단점이 있는데 아주 작은 소프트웨어거나 대규모 소프트웨어 일부분을 테스트 할 때만 사용할 수 있다. 예를 들어 1000개의 넘는 항목일 경우는 경우의 수가 너무 많아져서 테스트 할 수 없다.<br>대신 항목이 적고 복잡하게 움직이는 소프트웨어에 대해서는 특정 경우가 빠지는 것을 막을 수 있기 때문에 유용한 방법이다.<br>책을 읽으면서 계속 느끼는 것이지만, 하나의 소프트웨어 안에서도 기능에 따라 적합한 테스트 방법을 적용 해야 효율적인 테스트를 할 수 있다.<br>상태 전이 테스트</p><p>일반적으로 요즘 소프트웨어는 항상 같은 상태에 있는 것이 아니라 상태를 변화 시켜 소프트웨어의 조작을 쉽도록 한다. 예를 들어 워드 프로세서와 같은 프로그램에서 파일을 열기 위해 파일 열기 메뉴를 클릭 했을 때 파일 열기 대화 상자가 표시되는 것은 상태 변화 이다. 만약에 이런 상태 변화가 없다면 사용하기 매우 어려운 소프트웨어가 될 것이다.</p><p><img src="/img/SoftwareTest_White_Black/State_Transition.png" alt="메모장의 파일 열기와 파일 저장의 상태 전이"></p><p>상태 전이 테스트는 UI 를 테스트 할 때 유용한 테스트가 된다. 이 때 발견할 수 있는 버그는 기대하지 않은 상태로 전이하는 버그 ( 쌩뚱맞은 화면으로 넘어가는 버그 ), 전이 자체가 일어 나지 않는 버그 ( 화면이나 동작의 변경이 없는 버그 ) 가 있다. </p><p>마찬가지로 상태 전이 테스트도 문제점이 있는데, 상태의 수가 너무 많은 경우 테스트 항목이 너무 늘어나서 테스트 할 수 없게 된다. 게다가 모델링 시간이 너무 걸리게 되어 실제 테스트 하는 시간이 부족해 진다.  20~30개 정도의 상태 전이가 일어나는 소프트웨어는 직접 모델링 할 수 있으나, 100개 이상의 상태 전이가 일어나는 소프트웨어는 반드시 지원 도구를 사용해야 모델링에 효율을 높일 수 있다.</p><h2 id="무작위-테스트-Monkey-Test"><a href="#무작위-테스트-Monkey-Test" class="headerlink" title="무작위 테스트 ( Monkey Test )"></a>무작위 테스트 ( Monkey Test )</h2><p>아무것도 생각하지 않고 입력이나 조작을 수행하는 방법을 말한다. 에드혹(Ad-hoc) 테스트, 애드립 테스트, 무작위 테스트, 몽키 테스트 와 같이 굉장히 다양한 이름으로 불리고 있다. 그러니 누군가가 몽키 테스트 라는 것 아느냐 라고 물어 본다면 당황하지 말길..<br>이 테스트 방법도 전혀 효과가 없는 것은 아니니 빼먹지 않고 써보면 좋을 듯 하다. (의외로 많은 버그가 이 방법으로 발견되곤 한다. 소프트웨어를 이해하지 못한 사용자가 써보면 그게 무작위 테스트가 되는 것은 아닐까? 그래서 처음 사용하는 사용자가 버그를 많이 발견 해내나?)</p><p>소프트웨어 테스팅의 주요 목적은  많은 버그를 찾는 것이다. 하지만 보다 중요한 것은 효율적으로 버그를 찾는 것이다. 똑똑하지 않은 테스트를 많은 시간을 들여서 했다고 그만큼 소프트웨어의 품질이 올라가지 않는다는 뜻이다. 소프트웨어 테스팅 기법이라는 도구들로 똑똑한 테스트를 해 보자.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이번 포스팅에서는 화이트 박스 테스트와 블랙 박스 테스트에 대해서 이야기 해 보고자 한다.&lt;br&gt;물론 “지식 제로부터 배우는 소프트웨어 테스트” 를 읽고 공부한 내용이다.&lt;/p&gt;
&lt;h2 id=&quot;화이트-박스-테스트-란-무엇인가&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="Software Test" scheme="https://slim8020.github.io/categories/Software-Test/"/>
    
    
      <category term="SoftwareTest" scheme="https://slim8020.github.io/tags/SoftwareTest/"/>
    
      <category term="소프트웨어테스트" scheme="https://slim8020.github.io/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%ED%85%8C%EC%8A%A4%ED%8A%B8/"/>
    
      <category term="WhiteBox" scheme="https://slim8020.github.io/tags/WhiteBox/"/>
    
      <category term="BlackBox" scheme="https://slim8020.github.io/tags/BlackBox/"/>
    
      <category term="화이트박스테스트" scheme="https://slim8020.github.io/tags/%ED%99%94%EC%9D%B4%ED%8A%B8%EB%B0%95%EC%8A%A4%ED%85%8C%EC%8A%A4%ED%8A%B8/"/>
    
      <category term="블랙박스테스트" scheme="https://slim8020.github.io/tags/%EB%B8%94%EB%9E%99%EB%B0%95%EC%8A%A4%ED%85%8C%EC%8A%A4%ED%8A%B8/"/>
    
  </entry>
  
  <entry>
    <title>테스트 케이스 만들기</title>
    <link href="https://slim8020.github.io/2019/08/07/SoftwareTest_TestCase/"/>
    <id>https://slim8020.github.io/2019/08/07/SoftwareTest_TestCase/</id>
    <published>2019-08-07T14:13:03.000Z</published>
    <updated>2021-04-17T00:31:06.199Z</updated>
    
    <content type="html"><![CDATA[<p>이 포스트는 “지식 제로부터 배우는 소프트웨어 테스트”를 읽고 학습한 내용입니다.</p><h2 id="소프트웨어-테스트-지식의-필요성"><a href="#소프트웨어-테스트-지식의-필요성" class="headerlink" title="소프트웨어 테스트 지식의 필요성"></a>소프트웨어 테스트 지식의 필요성</h2><p>사회에 나오고 제일 먼저 접했던 것이 소프트웨어 테스팅이라는 것이었다. 그 때는 팀장님이 스터디해서 발표 해봐 라고 하셔서 의무적으로 공부 했었다. Validation 이니 Verification 이니 Blackbox Test 니 Whitebox Test 니 학교에서 배운 적 없는 용어들이 난무하는 이 분야에 대해서 어렵게만 생각했었다.<br>개발 경력을 쌓아 나가면서 점점 소프트웨어의 품질에 대해서 관심이 생겼고, Project Manager 이자 Product Manager가 된 이 상황에서는 필수적인 지식이 되어야 했다. ( 근데 아는 게 없다. 회사 생활하면서 테스터들이 테스트 하는 것을 본 경험과 기본 개념 정도? )</p><p>이런 상황(PM 이 될 상황)들을 예상이라도 했듯이 1년 전에 테스터의 필요성을 설파하여, 지금은 팀에 테스트를 담당하는 멤버가 있다. 하지만 테스트 담당자가 대학교를 갓 졸업한 신입이라 “테스트는 그냥 만들어진 소프트웨어를 이것저것 눌러보다 발견된 문제점을 리포트 하는 것” 이라는 생각을 가지고 있었다. 1년이 지난 지금은 아니지만..</p><p>문제는 테스트 담당자는 있는데 경력이 없어서 테스트에 대해서는 문외한이라는 점이다. 그렇다고 가르쳐 주면서 일을 할 사람도 없다. 혼자서 공부를 하면서 일을 해 나가는데 어려움을 많이 겪고 있고, 나도 테스트 업무를 지시할 때 명확하지 못한 업무를 지시하는 경우가 많았다.</p><p>그래서 뒤늦게나마 책이라도 한권 읽고 중심이라도 잡아보자 라는 심정으로 읽게 된 책이 “지식 제로부터 배우는 소프트웨어 테스트” 이다.</p><p>책을 읽고 감상평만 쓰는 것은 항상 의미가 없다라는 생각이 들어서 실전에서 적용하는 사례를  책을 읽으면서 포스팅을 해 나갈 예정이다.</p><p>일단 오늘 읽은 데 까지만 포스팅!</p><p>소프트웨어 테스트 관련 책이 다 똑같듯이 테스트가 안 되면 어떤 문제가 발생하는지에 대한 것들이 초반에 나온다. 주로 많이 나오는게 나사 이야기 인데 여기서도…그 부분은 패스하고 “소프트웨어 테스트 실력 점검” 에 대해서 한번 해보겠다.</p><h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><p><img src="/img/SoftwareTest_TestCase/SoftwareTest_Question1.jpeg" alt="예시"></p><p>문제에 해당 하는 내용으로 일단 개발자 입장에서 프로그램을 작성 해 봤다.<br>Visual studio 2015 에서 C# 으로 작성 해 본 코드 이다.</p><p><img src="/img/SoftwareTest_TestCase/Code.png" alt="예제 코드"></p><h2 id="테스트-케이스"><a href="#테스트-케이스" class="headerlink" title="테스트 케이스"></a>테스트 케이스</h2><p>이제 테스터 입장에서 테스트 케이스를 설계 해 보겠다.<br>( * 테스트 케이스란 무엇인가?<br>     테스트 케이스가 무엇인지 정의한 내용을 구글에서 검색을 했는데 적당한 답을 찾지 못했다.잘 정리      해 두신 분도 있긴 한데..  내가 생각하는 정의는 “개발한 소프트웨어의 동작에 대해서 검사할 항목”        이다.)<br><img src="/img/SoftwareTest_TestCase/TC.png" alt="내가 설계한 테스트 케이스"></p><h2 id="정답은"><a href="#정답은" class="headerlink" title="정답은?"></a>정답은?</h2><p><img src="/img/SoftwareTest_TestCase/Answer.jpeg" alt="책에서 제시한 답"></p><p>몇 개의 케이스를 놓쳤다. 특히 두 변의 합이 다른 한변의 합과 같음. 두 변의 합이 다른 한변의 합보다 적음 의 경우는 기하학적 지식(?)까지 요구 하는 내용이다. 사실 테스트라는게 소프트웨어의 도메인(적용되는 분야)에 대한 지식도 요구되는 작업은 맞다. 그래서 인정!</p><p>테스트 케이스를 작성하는 것은 프로그램을 작성하는 것보다<br>실제로 더 어려운 일입니다.</p><p>작가의 말도 인정!<br>다음 포스팅에서는 화이트박스 테스트와 블랙박스 테스트에 대해서 읽고 정리 해 보려고 한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이 포스트는 “지식 제로부터 배우는 소프트웨어 테스트”를 읽고 학습한 내용입니다.&lt;/p&gt;
&lt;h2 id=&quot;소프트웨어-테스트-지식의-필요성&quot;&gt;&lt;a href=&quot;#소프트웨어-테스트-지식의-필요성&quot; class=&quot;headerlink&quot; title=&quot;소프트웨어
      
    
    </summary>
    
      <category term="Software Test" scheme="https://slim8020.github.io/categories/Software-Test/"/>
    
    
      <category term="SoftwareTest" scheme="https://slim8020.github.io/tags/SoftwareTest/"/>
    
      <category term="소프트웨어테스트" scheme="https://slim8020.github.io/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%ED%85%8C%EC%8A%A4%ED%8A%B8/"/>
    
      <category term="TestCase" scheme="https://slim8020.github.io/tags/TestCase/"/>
    
      <category term="테스트케이스" scheme="https://slim8020.github.io/tags/%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%BC%80%EC%9D%B4%EC%8A%A4/"/>
    
      <category term="SQA" scheme="https://slim8020.github.io/tags/SQA/"/>
    
  </entry>
  
</feed>
